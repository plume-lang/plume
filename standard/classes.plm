native "std:native" to_string<A>(x: A): str
native "std:native" {
  copy_ref<A>(x: A): A
  free_ref<A>(x: A): A
}

interface<A> show<A> {
  fn show(a: A): str
}

interface<A> boolean_algebra<A> {
  fn and(x: A, y: A): A
  fn or(x: A, y: A): A
  fn not(b: A): A
}

interface<A> to_str<A> {
  fn to_str(a: A): str
}

interface<A> from_str<A> {
  fn from_str(s: str): A
}

interface<A> coercible<A> {
  fn from<B>(b: B): A
  fn to<B>(a: A): B
}

interface<A extends boolean_algebra> equality<A> {
  fn (==)(a: A, b: A): bool
}

interface<A> numeric<A> {
  fn (+)(a: A, b: A): A
  fn (-)(a: A, b: A): A
}

interface<A> product<A> {
  fn (*)(a: A, b: A): A
  fn (/)(a: A, b: A): A
  fn (^)(a: A, b: int): A
}

interface<A> ordering<A> {
  fn (<)(a: A, b: A): bool
}

interface<T> traversable<T> {
  fn map<A, B>(self: T<A>, f: fn(A): B): T<B>
}

interface<T> foldable<T> {
  fn foldl<A, B>(self: T<A>, f: fn(B, A): B, init: B): B
}

interface<T> indexable<T> {
  fn get_index<A>(self: T<A>, i: int): Option<A>
}

interface<A> monoidal<A> {
  fn empty(): A
  fn concat(a: A, b: A): A
}