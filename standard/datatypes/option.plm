type Option<A> {
  None,
  Some(A)
}

extend<A> (this: Option<A>) {
  fn map<B>(f: (A) -> B): Option<B> =>
    switch this {
      case None => None
      case Some(a) => Some(f(a))
    }
    
  fn show(showSome: (A) -> str): str =>
    switch this {
      case None => "None"
      case Some(a) => "Some({a.showSome()})"
    }

  fn flatMap<B>(f: (A) -> Option<B>): Option<B> =>
    switch this {
      case None => None
      case Some(a) => f(a)
    }

  fn getOrElse(f: () -> A): A =>
    switch this {
      case None => f()
      case Some(a) => a
    }

  fn isNone(): bool =>
    switch this {
      case None => true
      case Some(?) => false
    }

  fn isSome(): bool =>
    switch this {
      case None => false
      case Some(?) => true
    }
}