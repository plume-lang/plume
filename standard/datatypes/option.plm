require "string"

type Option<T> {
  Some(T),
  None
}

// When the condition is true, the function is called and the result
// is wrapped in a Some.
fn when<A>(cond: bool, a: fn(): A): Option<A> =>
  if cond {
    return Some(a())
  } else {
    return None
  }

// When the condition is false, the function is called and the result
// is wrapped in a Some.
fn unless<A>(cond: bool, a: fn(): A): Option<A> =>
  if cond {
    return None
  } else {
    return Some(a())
  }

// Defining control flow constructrs
type Control<A> { 
  Return(A),
  Break,
  Continue
}

// Implementing a while loop using a recursive function and 
// the Control type.
fn while<A>(cond: fn(): bool, body: fn(): Control<A>): Option<A> =>
  if cond() {
    return switch body() {
      case Return(x) => Some(x)
      case Break => None
      case Continue => while(cond, body)
    }
  } else {
    return None
  }


extend<A extends show> show<Option<A>> {
  fn show(o: Option<A>): str => switch o {
    case Some(x) => "Some(" + x.show() + ")"
    case None => "None"
  }
}
