require "string"

type Option<T> {
  Some(T),
  None
}

// When the condition is true, the function is called and the result
// is wrapped in a Some.
fn when<A>(cond: bool, a: fn(): A): Option<A> =>
  if cond {
    Some(a())
  } else {
    None
  }

// When the condition is false, the function is called and the result
// is wrapped in a Some.
fn unless<A>(cond: bool, a: fn(): A): Option<A> =>
  if cond {
    None
  } else {
    Some(a())
  }

// Defining control flow constructrs
type Control<A> { 
  Return(A),
  Break,
  Continue
}

// Implementing a while loop using a recursive function and 
// the Control type.
fn while<A>(cond: fn(): bool, body: fn(): Control<A>): Option<A> =>
  if cond() {
    switch body() {
      case Return(x) => Some(x)
      case Break => None
      case Continue => while(cond, body)
    }
  } else {
    None
  }


extend<A> (c: Option<A>) {
  fn show(showH: fn(A): str): str => 
    switch c {
      case Some(a) => "Some(" + a.showH() + ")"
      case None => "None"
    }

  // Returns the value by calling the callback `f` if the option is Some.
  // Otherwise, returns the default value.
  fn maybe<B>(default: B, f: fn(A): B): B => 
    switch c {
      case Some(a) => f(a)
      case None => default
    }

  fn is_some(): bool => 
    switch c {
      case Some(?) => true
      case None => false
    }
  fn is_none(): bool => 
    switch c {
      case Some(?) => false
      case None => true
    }
  
  // Overloading the `or` operator to provide a default value.
  fn or(default: A): A => 
    switch c {
      case Some(a) => a
      case None => default
    }
  
  // Converting a `Some` to a list with one element, or an empty list.
  fn to_list(): [A] =>
    switch c {
      case Some(a) => [a]
      case None => []
    }
  
  // Like a functor mapping on optional values.
  // If the value is `None`, the function is not called.
  // If the value is `Some`, the function is called and the result 
  // is wrapped in a `Some`.
  fn map<B>(f: fn(A): B): Option<B> => 
    switch c {
      case Some(a) => Some(f(a))
      case None => None
    }
  
  // Like a monad bind on optional values.
  // If the value is `None`, the function is not called.
  // If the value is `Some`, the function is called and the result
  // is returned.
  fn and_then<B>(f: fn(A): Option<B>): Option<B> =>
    switch c {
      case Some(a) => f(a)
      case None => None
    }

  // Returns the value if it is `Some`, otherwise calls the function `f`.
  // This corresponds to the `or` method but with a function instead of
  // a value (used for lazy evaluation).
  fn get_or_else(f: fn(): A): A =>
    switch c {
      case Some(a) => a
      case None => f()
    }
}