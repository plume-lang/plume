type Result<A, B> {
  Error(A),
  Ok(B)
}

extend<A, B> (this: Result<A, B>) {
  fn map<C>(f: (B) -> C): Result<A, C> =>
    switch this {
      case Error(a) => Error(a)
      case Ok(b) => Ok(f(b))
    }

  fn show(showError: (A) -> str, showOk: (B) -> str): str =>
    switch this {
      case Error(a) => "Error({a.showError()})"
      case Ok(b) => "Ok({b.showOk()})"
    }
  
  fn flatMap<C>(f: (B) -> Result<A, C>): Result<A, C> =>
    switch this {
      case Error(a) => Error(a)
      case Ok(b) => f(b)
    }

  fn getOrElse(f: (A) -> B): B =>
    switch this {
      case Error(a) => f(a)
      case Ok(b) => b
    }
  
  fn isError(): bool =>
    switch this {
      case Error(?) => true
      case Ok(?) => false
    }
  
  fn isOk(): bool =>
    switch this {
      case Error(?) => false
      case Ok(?) => true
    }
}