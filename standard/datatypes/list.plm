require "number"
require "tuple"

native "std:native" {
  list_append<A>(x: [A], y: A): [A]
  list_prepend<A>(x: [A], y: A): [A]
  list_concat<A>(x: [A], y: [A]): [A]
  ffi_get_index<A>(x: [A], i: int): Option<A>
  ffi_slice_list<A>(x: [A], start: int, end: int): [A]
}

extend indexable<list> {
  fn get_index<A>(self: list<A>, i): Option<A> => ffi_get_index(self, i)
}

extend traversable<list> {
  fn map<A, B>(self: list<A>, f: fn(A): B): list<B> => switch self {
    case [] => []
    case [x, ..xs] => xs.map(f).list_prepend(f(x))
  }
}

extend foldable<list> {
  fn foldl<A, B>(self: list<A>, f: fn(B, A): B, init: B): B => switch self {
    case [] => init
    case [x, ..xs] => xs.foldl(f, f(init, x))
  }
}

fn length<T extends foldable, A>(x: T<A>) => 
  x.foldl(fn (acc, _) => acc + 1, 0)

fn filter<T extends foldable, A>(x: T<A>, f: fn(A): bool) => 
  x.foldl(fn (acc, y) => if (f(y)) acc.list_append(y) else acc, [])

fn elem<T extends foldable, A extends equality>(x: T<A>, y: A) => 
  x.foldl(fn (acc, z) => acc or z == y, false)

fn showListHelper<A extends show>(ls: list<A>): str => switch ls {
  case [] => ""
  case [x] => x.show()
  case [x, ..xs] => x.show() + ", " + showListHelper(xs)
}

extend<A extends show> show<list<A>> {
  fn show(self: list<A>): str => "[" + showListHelper(self) + "]"
}

extend<A extends equality> numeric<list<A>> {
  fn (+) (x, y) => x.list_concat(y)
  fn (-) (x, y) => x.filter(fn (z) => not elem(y, z))
}

extend<A extends equality> equality<list<A>> {
  fn (==) (x, y) => switch (x, y) {
    case ([], []) => true
    case ([], ?) => false
    case (?, []) => false
    case ([a, ..as], [b, ..bs]) => (a == b) and (as == bs)
  }
}

fn slice<A>(xs: [A], start: int): [A] => switch (xs, start) {
  case ([], ?) => []
  case ([y, ..ys], 0) => xs
  case ([?, ..ys], ?) => slice(ys, start - 1)
}

fn find<T extends foldable, A, B>(x: T<(A, B)>, f: fn(A): bool): Option<B> =>
  x.foldl(fn (acc, tp) => switch tp {
    case tuple(a, b) => if (f(a)) Some(b) else acc
  }, None)