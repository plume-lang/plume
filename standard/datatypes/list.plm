require "number"
require "tuple"

native "std:native" {
  list_append<A>(x: [A], y: A): [A]
  list_prepend<A>(x: [A], y: A): [A]
  list_concat<A>(x: [A], y: [A]): [A]
  ffi_get_index<A>(x: [A], i: int): Option<A>
  ffi_slice_list<A>(x: [A], start: int, end: int): [A]
}

interface<T> traversable<T> {
  fn map<A, B>(self: T<A>, f: fn(A): B): T<B>
}

interface<T> foldable<T> {
  fn foldl<A, B>(self: T<A>, f: fn(B, A): B, init: B): B
}

extend traversable<list> {
  fn map<A, B>(self: list<A>, f: fn(A): B): list<B> => switch self {
    case [] => []
    case [x, ..xs] => xs.map(f).list_append(f(x))
  }
}

extend foldable<list> {
  fn foldl<A, B>(self: list<A>, f: fn(B, A): B, init: B): B => switch self {
    case [] => init
    case [x, ..xs] => xs.foldl(f, f(init, x))
  }
}

fn length<T extends foldable, A>(x: T<A>) => 
  x.foldl(fn (acc, _) => acc + 1, 0)

fn filter<T extends foldable, A>(x: T<A>, f: fn(A): bool) => 
  x.foldl(fn (acc, y) => if (f(y)) acc.list_append(y) else acc, [])

fn elem<T extends foldable, A extends equality>(x: T<A>, y: A) => 
  x.foldl(fn (acc, z) => acc or z == y, false)

fn showListHelper<A extends show>(ls: list<A>): str => switch ls {
  case [] => ""
  case [x] => x.show()
  case [x, ..xs] => x.show() + ", " + showListHelper(xs)
}

extend<A extends show> show<list<A>> {
  fn show(self: list<A>): str => "[" + showListHelper(self) + "]"
}

extend<A extends equality> numeric<list<A>> {
  fn (+) (x, y) => x.list_concat(y)
  fn (-) (x, y) => x.filter(fn (z) => not elem(y, z))
}