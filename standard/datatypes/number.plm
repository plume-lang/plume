native "std:native" {
  add_int(x: int, y: int): int
  sub_int(x: int, y: int): int
  mul_int(x: int, y: int): int
  div_int(x: int, y: int): int
  mod_int(x: int, y: int): int
  float_to_int(x: float): int
  int_to_float(x: int): float
  eq_int(x: int, y: int): bool
  lt_int(x: int, y: int): bool
}

// Native float functions
native "std:native" {
  add_float(x: float, y: float): float
  sub_float(x: float, y: float): float
  mul_float(x: float, y: float): float
  div_float(x: float, y: float): float
  mod_float(x: float, y: float): float
  pow_float(x: float, y: float): float
  eq_float(x: float, y: float): bool
  lt_float(x: float, y: float): bool
}

require "string"
require "bool"

infix 3 ^
infixr 2 !=

extend numeric<int> {
  fn (+) (c: int, d: int) => add_int(c, d)
  fn (-) (x: int, y: int) => sub_int(x, y)
}

extend int {
  fn (*) (c: int, d: int): int => mul_int(c, d)
}

extend show<int> {
  fn show(c: int) => to_string(c)
}

fn (/) (c: int, d: int) => div_int(c, d)
fn (%) (c: int, d: int) => mod_int(c, d)
fn (^) (c: int, d: int) => switch d {
  case 0 => 1
  case ? => c * (c ^ (d - 1))
}

extend to_str<int> {
  fn to_str(c: int) => to_string(c)
}

extend equality<int> {
  fn (==) (x: int, y: int) => eq_int(x, y)
}

extend ordering<int> {
  fn (<) (x: int, y: int) => lt_int(x, y)
}

// Defining math functions

// fn (/) (d: float) => div_float(c, d)
// fn (%) (d: float) => mod_float(c, d)
// fn (-) (d: float) => sub_float(c, d)
// fn (^) (d: float) => pow_float(c, d)

extend numeric<float> {
  fn (+) (c: float, d: float) => add_float(c, d)
  fn (-) (x: float, y: float) => sub_float(x, y)
}

extend float {
  fn (*) (c: float, d: float): float => mul_float(c, d)
}

extend equality<float> {
  fn (==) (x: float, y: float) => eq_float(x, y)
}

extend ordering<float> {
  fn (<) (x: float, y: float) => lt_float(x, y)
}

extend show<float> {
  fn show(c: float) => to_string(c)
}

extend to_str<float> {
  fn to_str(c: float) => to_string(c)
}

macro e = 2.718282
fn expf(x: float): float => pow_float(@e, x)
fn exp(x: int): float => expf(x.int_to_float())
